(in-package #:yid)

(defmacro define-fixed-point-generic (name (&rest arguments) bottom &body body)
  (let ((cache (gensym "CACHE"))
        (changedp (gensym "CHANGEDP"))
        (runningp (gensym "RUNNINGP"))
        (visited (gensym "VISITED")))
    `(progn
       (defvar ,cache (make-hash-table :test #'eq :weak :key))
       (defvar ,changedp nil)
       (defvar ,runningp nil)
       (defvar ,visited)
       (defgeneric ,name (,@arguments)
         (:method :around (,@arguments)
           (multiple-value-bind (cached-value cachedp)
               (gethash ,(car arguments) ,cache)
             (cond ((and cachedp (not ,runningp)) cached-value)
                   ((and ,runningp (gethash ,(car arguments) ,visited))
                    (if cachedp cached-value ,bottom))
                   (,runningp
                    (setf (gethash ,(car arguments) ,visited) t)
                    (let ((new-val (call-next-method)))
                      (when (not (equal new-val cached-value))
                        (setf ,changedp                         t
                              (gethash ,(car arguments) ,cache) new-val))
                      new-val))
                   ((not (or cachedp ,runningp))
                    (do ((,changedp t)
                         (,runningp t)
                         (v ,bottom)
                         (,visited (make-hash-table :test #'eq :weak :key)
                                   (make-hash-table :test #'eq :weak :key)))
                        ((not ,changedp) v)
                      (declare (special ,changedp ,runningp ,visited))
                      (setf ,changedp nil
                            v (call-next-method)))))))
         ,@body))))

(defmacro define-memoized-generic
    (name (&rest arguments) key test &body body)
  (let ((cache (gensym "CACHE")))
    `(let ((,cache (make-hash-table :test ,test)))
       (defgeneric ,name (,@arguments)
         (:method :around (,@arguments)
                  (multiple-value-bind (value foundp)
                      (gethash (,key (list ,@arguments)) ,cache)
                    (if foundp
                        value
                        (setf (gethash (,key (list ,@arguments)) ,cache)
                              (call-next-method)))))
         ,@body))))

(defmacro define-searched-generic
    (name (x &rest arguments) reentry &body body)
  "Allows recursive functions on graphs by turning them into graph searches."
  (let ((visited (gensym "VISITED"))
        (def (gensym "DEF")))
    `(let ((,visited nil)
           (,def ,reentry))
       (declare (special ,visited))
       (defgeneric ,name (,x ,@arguments)
         (:method :around (,x ,@arguments)
                  (cond ((not ,visited)
                         (let ((,visited (make-hash-table)))
                           (call-next-method)))
                        ((gethash ,x ,visited)
                         (if (function def) (funcall ,def ,x) ,def))
                        (t (setf (gethash ,x ,visited) t)
                           (call-next-method))))
         ,@body))))
